<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description"
    content="Proyecto Arduino: Sistema de activación Boost con Filtro Kalman y doble sensor HC-SR04.">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            tone: {
              dark: '#011F26',
              teal: '#025E73',
              olive: '#A5A692',
              beige: '#BFB78F',
              gold: '#F2A71B',
            }
          }
        }
      }
    }
  </script>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark')
    } else {
      document.documentElement.classList.remove('dark')
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>Arduino: Boost con Kalman — Félix Lara</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    .code-bg {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid #025E73;
    }

    html:not(.dark) .code-bg {
      background: #1f2937;
      border-color: #e5e7eb;
    }
  </style>
</head>

<body class="bg-gray-50 text-gray-900 dark:bg-tone-dark dark:text-gray-100 transition-colors duration-300">

  <!-- Botón Toggle Idioma (Nuevo) -->
  <button id="lang-toggle"
    class="absolute top-6 right-20 z-50 p-2 rounded-full bg-white text-gray-500 hover:bg-gray-100 shadow-lg dark:bg-tone-teal dark:text-gray-200 dark:hover:bg-tone-teal/80 transition-all font-bold text-xs w-10 h-10 flex items-center justify-center">
    ES
  </button>

  <!-- Toggle tema -->
  <button id="theme-toggle"
    class="absolute top-6 right-6 z-50 p-2 rounded-full bg-white text-gray-500 hover:bg-gray-100 shadow-lg dark:bg-tone-teal dark:text-gray-200 transition-all">
    <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden dark:block" fill="none" stroke="currentColor"
      viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
        d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
      </path>
    </svg>
    <svg id="theme-toggle-dark-icon" class="w-6 h-6 block dark:hidden" fill="none" stroke="currentColor"
      viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
        d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
    </svg>
  </button>

  <header class="container mx-auto px-6 pt-10 pb-10 max-w-4xl">
    <nav class="mb-8">
      <a href="blog.html" class="text-tone-gold hover:underline font-medium inline-flex items-center gap-1">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
        </svg>
        <span data-i18n="sensor_page.footer_back">Volver al blog</span>
      </a>
    </nav>
    <h1 class="text-3xl md:text-4xl font-bold text-tone-dark dark:text-white mb-4 tracking-tight"
      data-i18n="boost_page.title">
      Sistema Optimizado de Detección y Activación de Boost con Filtro Kalman
    </h1>
    <div class="flex gap-4 text-sm text-gray-500 dark:text-gray-400 border-b border-gray-200 dark:border-gray-700 pb-6">
      <span data-i18n="boost_page.breadcrumbs.cat">C++ / Arduino</span>
      <span>•</span>
      <span data-i18n="boost_page.breadcrumbs.tag1">Optimización</span>
      <span>•</span>
      <span data-i18n="boost_page.breadcrumbs.tag2">Filtros Digitales</span>
    </div>
  </header>

  <main class="container mx-auto px-6 pb-20 max-w-4xl text-gray-800 dark:text-gray-300 leading-relaxed space-y-8">

    <section>
      <p class="text-lg" data-i18n="boost_page.intro.p1" data-i18n-html="true">
        Este proyecto implementa un sistema robusto de detección de distancia utilizando dos sensores
        ultrasónicos
        <span class="font-semibold text-tone-teal dark:text-tone-beige">HC-SR04</span> en un Arduino UNO.
        El objetivo es activar un sistema "Boost" (simulado con un LED) solo cuando la detección es estable y
        confiable.
      </p>
      <p class="mt-4" data-i18n="boost_page.intro.p2" data-i18n-html="true">
        Para lograr esto en un microcontrolador con recursos limitados (2KB SRAM), se implementó un
        <span class="font-semibold text-tone-gold">Filtro Kalman 1D optimizado para enteros</span>, evitando el
        uso costoso de números de punto flotante.
      </p>
    </section>

    <section>
      <h2 class="text-2xl font-bold text-tone-dark dark:text-white mb-4" data-i18n="boost_page.features.title">
        Características Clave</h2>
      <ul class="list-disc list-inside space-y-2 ml-2">
        <li data-i18n="boost_page.features.item1" data-i18n-html="true"><span class="font-semibold">Optimización de
            Memoria:</span> Uso extensivo de <code>PROGMEM</code> y
          tipos de datos <code>uint8_t</code>.</li>
        <li data-i18n="boost_page.features.item2" data-i18n-html="true"><span class="font-semibold">Filtro Kalman
            Entero:</span> Cálculos escalados (x10, x100) para
          mantener precisión sin <code>float</code>.</li>
        <li data-i18n="boost_page.features.item3" data-i18n-html="true"><span class="font-semibold">Redundancia:</span>
          Fusión de datos de dos sensores para mayor
          fiabilidad.</li>
        <li data-i18n="boost_page.features.item4" data-i18n-html="true"><span class="font-semibold">Estabilidad:</span>
          Historial de estimaciones para evitar falsos
          positivos por ruido.</li>
      </ul>
    </section>

    <!-- Nueva Sección: Galería de Imágenes -->
    <section>
      <h2 class="text-2xl font-bold text-tone-dark dark:text-white mb-6" data-i18n="boost_page.gallery.title">Montaje y
        Pruebas</h2>
      <div class="grid md:grid-cols-2 gap-6">

        <!-- Imagen 1 -->
        <figure class="space-y-3">
          <div class="rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700 shadow-sm">
            <!-- Reemplaza src con tu imagen real -->
            <img src="images/arduino.jpg" alt="Montaje en protoboard del sistema Arduino"
              class="w-full h-auto object-cover hover:scale-105 transition duration-500">
          </div>
          <figcaption class="text-sm text-center text-gray-500 dark:text-gray-400 italic"
            data-i18n="boost_page.gallery.cap1">
            Vista general del circuito con Arduino Uno y sensores HC-SR04.
          </figcaption>
        </figure>

        <!-- Imagen 3 -->
        <figure class="space-y-3">
          <div class="rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700 shadow-sm">
            <!-- Reemplaza src con tu imagen real -->
            <img src="images/carrito.jpg" alt="Carrito de pruebas con sensores montados"
              class="w-full h-auto object-cover hover:scale-105 transition duration-500">
          </div>
          <figcaption class="text-sm text-center text-gray-500 dark:text-gray-400 italic"
            data-i18n="boost_page.gallery.cap2">
            Vista del carrito RC de pruebas con sensores montados.
          </figcaption>
        </figure>

      </div>
    </section>

    <!-- Sección Simulación Tinkercad -->
    <section>
      <h2 class="text-2xl font-bold text-tone-dark dark:text-white mb-4" data-i18n="boost_page.sim.title">Simulación
      </h2>
      <div
        class="bg-white dark:bg-tone-teal/10 border border-gray-200 dark:border-tone-teal/40 rounded-lg p-6 shadow-sm flex flex-col sm:flex-row items-center justify-between gap-4">
        <div>
          <h3 class="font-semibold text-tone-dark dark:text-white mb-1" data-i18n="boost_page.sim.sub">Pruébalo en
            Tinkercad</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400" data-i18n="boost_page.sim.desc">
            Accede al esquema interactivo, explora las conexiones y ejecuta el código en el simulador.
          </p>
        </div>
        <a href="https://www.tinkercad.com/things/lNDJherLEg8-kalman-optimizado-usando-enteros" target="_blank"
          rel="noopener noreferrer"
          class="whitespace-nowrap inline-flex items-center gap-2 bg-tone-gold text-tone-dark font-bold px-5 py-3 rounded-lg hover:bg-yellow-500 transition shadow-md">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
          </svg>
          <span data-i18n="boost_page.sim.btn">Abrir Simulador</span>
        </a>
      </div>
    </section>

    <section>
      <h2 class="text-2xl font-bold text-tone-dark dark:text-white mb-4" data-i18n="boost_page.code.title">Código Fuente
      </h2>
      <p class="mb-4" data-i18n="boost_page.code.desc">
        A continuación se presenta el código completo optimizado para Arduino UNO.
      </p>
      <div class="code-bg p-6 rounded-lg overflow-x-auto shadow-inner max-h-[600px] overflow-y-auto">
        <pre><code class="text-xs font-mono text-gray-100">
// ============================================================
//  SISTEMA OPTIMIZADO DE DETECCIÓN Y ACTIVACIÓN DE BOOST CON FILTRO KALMAN
//  Para dos sensores HC-SR04 en Arduino UNO (16 MHz, 2 KB SRAM)
//  Optimización: Memoria, Rendimiento y Determinismo Temporal
// ============================================================

#include &lt;avr/pgmspace.h&gt;

// — Definiciones de pines —
#define TRIG1 11
#define ECHO1 12
#define TRIG2 3
#define ECHO2 4
#define LED_PIN 2  // LED_BUILTIN es generalmente el pin 13
#define LED_INDICATOR A0

//#define DEBUG

// — Parámetros de distancia (en PROGMEM para ahorrar RAM) —
const PROGMEM uint8_t MIN_DIST = 2;            // cm, mínimo útil
const PROGMEM uint8_t MAX_DIST = 112;           // cm, máximo técnico fiable
const PROGMEM uint8_t SAFETY_MARGIN = 5;       // cm (aumentado a 2 para mayor robustez)
const PROGMEM uint8_t DIFFUSE_ZONE_START = 60; // cm, inicio de zona difusa (simplificado)
const PROGMEM uint8_t DIFFUSE_ZONE_END = 69;   // cm, fin de zona difusa
const PROGMEM uint8_t ACTIVATION_MIN = 70;  // Mínimo para activar LED

// — Parámetros de tiempo (uso de uint16_t optimizado) —
const PROGMEM uint16_t READ_INTERVAL = 10;     // ms entre lecturas (ajustable según necesidad)
const PROGMEM uint16_t LED_ON_DURATION = 4000; // ms LED encendido
const PROGMEM uint16_t LED_OFF_DURATION = 3000; // ms LED apagado

// — Estados del LED (codificación optimizada) —
#define LED_OFF 0
#define LED_ON 1
#define LED_WAIT_OFF 2
uint8_t currentLedState = LED_OFF;

// — Variables de tiempo (se mantienen como unsigned long para evitar overflow) —
unsigned long previousReadMillis = 0;
unsigned long ledStartMillis = 0;

// — Historial para estabilidad (optimizado para usar enteros) —
#define HISTORY_SIZE 5
uint8_t estimationHistory[HISTORY_SIZE] = {0};  // Cambiado a uint8_t
uint8_t historyIndex = 0;

// — Variables Kalman 1D (optimizadas) —
uint8_t kalman_x = 10;          // estado inicial (cm) como entero
uint8_t kalman_p_x10 = 10;      // incertidumbre inicial x10 para precisión sin flotantes
const uint8_t kalman_q0_x100 = 1; // ruido de proceso fijo x100 (0.01)
uint8_t kalman_q_x100 = 1;
uint8_t kalman_r1_x10 = 5;      // ruido medición sensor 1 x10 (0.5)
uint8_t kalman_r2_x10 = 5;      // ruido medición sensor 2 x10 (0.5)

// — Umbrales pre-calculados para optimizar comparaciones —
const uint8_t SAFE_MAX_DIST = MAX_DIST - SAFETY_MARGIN;  // 18 cm
const uint8_t STABLE_THRESHOLD_X10 = 2;  // 0.2 * 10
const uint8_t UNCERT_THRESHOLD_X10 = 3;  // 0.3 * 10

// — Factor para convertir duración a distancia (optimizado) —
// Original: duration * 0.0343 / 2.0
// Simplificado a: duration / 58 (estándar para HC-SR04 en cm)
#define DURATION_TO_CM_DIVISOR 58

// — Tiempo máximo de espera para echo en microsegundos —
// 25000 μs corresponde a ~4.3m (máximo teórico HC-SR04)
#define ECHO_TIMEOUT 25000

// — Declaraciones de funciones —
uint8_t read_distance(uint8_t trigPin, uint8_t echoPin);
uint8_t update_kalman(uint8_t z1, uint8_t z2);
uint8_t calculate_history_variation();

void setup() {
  // Configuración de pines optimizada (escritura directa a registros)
  pinMode(TRIG1, OUTPUT);
  pinMode(ECHO1, INPUT);
  pinMode(TRIG2, OUTPUT);
  pinMode(ECHO2, INPUT);
  pinMode(LED_PIN, OUTPUT);
  pinMode(LED_INDICATOR, OUTPUT);
  
  digitalWrite(LED_PIN, LOW);
  digitalWrite(LED_INDICATOR, LOW);
  
  #ifdef DEBUG
    Serial.begin(9600);
    Serial.println(F("SISTEMA INICIADO - OPTIMIZADO"));
  #endif
}

void loop() {
  unsigned long now = millis();
  
  // — Lectura y filtro cada READ_INTERVAL ms —
  if (now - previousReadMillis >= READ_INTERVAL) {
    previousReadMillis = now;
  
    // Lecturas de sensores (optimizadas)
    uint8_t z1 = read_distance(TRIG1, ECHO1);
    uint8_t z2 = read_distance(TRIG2, ECHO2);
    // Actualización Kalman y registro histórico (en enteros)
    uint8_t estimate = update_kalman(z1, z2);
    estimationHistory[historyIndex] = estimate;
    historyIndex = (historyIndex + 1) % HISTORY_SIZE;
    // Calcular variación histórica (optimizada para enteros)
    uint8_t variation = calculate_history_variation();
  
    #ifdef DEBUG
      Serial.print(F("z1:"));  Serial.print(z1);
      Serial.print(F(" z2:")); Serial.print(z2);
      Serial.print(F(" K:"));  Serial.print(estimate);
      Serial.print(F(" P:"));  Serial.print(kalman_p_x10);
      Serial.print(F(" V:"));  Serial.print(variation);
    #endif
  
    // — Condiciones de activación (optimizadas) —
    bool allValid = true;
    for (uint8_t i = 0; i < HISTORY_SIZE; i++) {
      if (estimationHistory[i] > SAFE_MAX_DIST) {
        allValid = false;
        break;
      }
    }
    // Evaluación de estabilidad y certidumbre (optimizada)
    bool stable = (variation <= STABLE_THRESHOLD_X10);
    bool lowUncert = (kalman_p_x10 < UNCERT_THRESHOLD_X10);
  
    // Lógica de activación (simplificada y optimizada)
    // if (estimate >= MIN_DIST && estimate <= SAFE_MAX_DIST &&
    if (estimate >= ACTIVATION_MIN && estimate <= SAFE_MAX_DIST &&
        allValid && stable && lowUncert &&
        currentLedState == LED_OFF) {
      // Verificación adicional con al menos una lectura válida
      if ((z1 > 0 && z1 <= SAFE_MAX_DIST) || (z2 > 0 && z2 <= SAFE_MAX_DIST)) {
        #ifdef DEBUG
          Serial.println(F(" -> ACTIVANDO"));
        #endif
        digitalWrite(LED_PIN, HIGH);
        digitalWrite(LED_INDICATOR, HIGH);
        currentLedState = LED_ON;
        ledStartMillis = now;
      }
    }
    #ifdef DEBUG
      else {
        // Mensajes de depuración omitidos en versión de producción
        if (estimate > SAFE_MAX_DIST)
          Serial.println(F(" -> FUERA RANGO"));
        else if (!allValid)
          Serial.println(F(" -> HIST NO VALIDO"));
        else if (!stable)
          Serial.println(F(" -> INESTABLE"));
        else if (!lowUncert)
          Serial.println(F(" -> INCERTIDUMBRE"));
        else if (currentLedState != LED_OFF)
          Serial.println(F(" -> EN CICLO"));
        else
          Serial.println(F(" -> BAJO RANGO"));
      }
      if (z1 == 0 && z2 == 0) {
        Serial.println(F(" -> SIN LECTURA"));
      }
    #endif
  }
  
  // — Control ciclo LED (optimizado) —
  if (currentLedState == LED_ON && now - ledStartMillis >= LED_ON_DURATION) {
    digitalWrite(LED_PIN, LOW);
    digitalWrite(LED_INDICATOR, LOW);
    currentLedState = LED_WAIT_OFF;
    ledStartMillis = now;
    #ifdef DEBUG
      Serial.println(F("LED OFF - ESPERA"));
    #endif
  }
  else if (currentLedState == LED_WAIT_OFF && now - ledStartMillis >= LED_OFF_DURATION) {
    currentLedState = LED_OFF;
    #ifdef DEBUG
      Serial.println(F("LISTO NUEVA ACTIVACION"));
    #endif
  }
}

// -------------------- Funciones Auxiliares (Optimizadas) --------------------

// Función de lectura de distancia optimizada para enteros
uint8_t read_distance(uint8_t trigPin, uint8_t echoPin) {
  // Secuencia de disparo optimizada
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  // Lectura de duración con timeout
  unsigned long duration = pulseIn(echoPin, HIGH, ECHO_TIMEOUT);
  // Validación y conversión a distancia (en cm)
  if (duration == 0) return 0;  // Sin eco válido
  // Conversión optimizada a centímetros (uint8_t)
  uint8_t d = duration / DURATION_TO_CM_DIVISOR;
  // Detección de zona difusa (optimizada)
  if (d > DIFFUSE_ZONE_START && d < DIFFUSE_ZONE_END) {
    #ifdef DEBUG
      Serial.print(F("DIFUSA:")); Serial.println(d);
    #endif
    return MAX_DIST + 1;  // Fuera de rango
  }
  // Restricción a rango útil
  if (d < MIN_DIST) return MIN_DIST;
  if (d > MAX_DIST) return MAX_DIST;
  return d;
}

// Filtro Kalman optimizado para enteros con escalado para mantener precisión
uint8_t update_kalman(uint8_t z1, uint8_t z2) {
  // — Predicción (trabajando con valores escalados) —
  kalman_p_x10 += (kalman_q_x100 / 10);  // q_x100/10 para mantener escala x10
  // — Actualización con z1 (si válido) —
  if (z1 > 0) {
    // Cálculo de ganancia Kalman optimizado
    uint16_t denominator = kalman_p_x10 + kalman_r1_x10;
    uint8_t k_x10 = (denominator > 0) ? ((10 * kalman_p_x10) / denominator) : 0;
    // Actualización de estado optimizada para evitar desbordamiento
    int16_t innovation = ((int16_t)z1 - (int16_t)kalman_x);
    kalman_x += (k_x10 * innovation) / 10;
    // Actualización de covarianza optimizada
    kalman_p_x10 = (kalman_p_x10 * (10 - k_x10)) / 10;
  }
  // — Actualización con z2 (si válido) —
  if (z2 > 0) {
    // Mismo proceso para z2
    uint16_t denominator = kalman_p_x10 + kalman_r2_x10;
    uint8_t k_x10 = (denominator > 0) ? ((10 * kalman_p_x10) / denominator) : 0;
    int16_t innovation = ((int16_t)z2 - (int16_t)kalman_x);
    kalman_x += (k_x10 * innovation) / 10;
    kalman_p_x10 = (kalman_p_x10 * (10 - k_x10)) / 10;
  }
  // — Ajuste dinámico de ruido de medición (simplificado y optimizado) —
  if (z1 > 0 && z2 > 0) {
    uint8_t diff = (z1 > z2) ? (z1 - z2) : (z2 - z1);
    if (diff > 1) {
      // Aumentar ruido (sensores discrepan)
      if (kalman_r1_x10 < 20) kalman_r1_x10++;  // Máximo 2.0
      if (kalman_r2_x10 < 20) kalman_r2_x10++;
    } else {
      // Disminuir ruido (sensores concuerdan)
      if (kalman_r1_x10 > 1) kalman_r1_x10--;  // Mínimo 0.1
      if (kalman_r2_x10 > 1) kalman_r2_x10--;
    }
  }
  // — Restricción del estado estimado —
  if (kalman_x < MIN_DIST) kalman_x = MIN_DIST;
  if (kalman_x > MAX_DIST) kalman_x = MAX_DIST;
  // — Reset q —
  kalman_q_x100 = kalman_q0_x100;
  return kalman_x;
}

// Cálculo de variación en historial optimizado para enteros
uint8_t calculate_history_variation() {
  uint8_t max_val = 0, min_val = 255;
  for (uint8_t i = 0; i < HISTORY_SIZE; i++) {
    uint8_t val = estimationHistory[i];
    if (val == 0) continue;  // Ignorar valores no inicializados
    if (val > max_val) max_val = val;
    if (val < min_val) min_val = val;
  }
  return (min_val == 255) ? 0 : (max_val - min_val);
}
</code></pre>
      </div>
    </section>

  </main>

  <footer
    class="container mx-auto px-6 pb-12 max-w-4xl text-sm text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700 pt-8">
    <p>Félix Lara — <a href="blog.html" class="hover:text-tone-gold hover:underline"
        data-i18n="sensor_page.footer_back">Volver al listado</a></p>
  </footer>

  <!-- i18next Scripts -->
  <script src="https://unpkg.com/i18next@23.7.11/i18next.min.js"></script>
  <script src="https://unpkg.com/i18next-browser-languagedetector@7.2.0/i18nextBrowserLanguageDetector.min.js"></script>
  <script src="js/translations.js"></script>
  <script src="js/i18n.js"></script>

  <script>
    // Script del toggle (copiado de index/blog)
    var themeToggleBtn = document.getElementById('theme-toggle');
    var darkIcon = document.getElementById('theme-toggle-dark-icon');
    var lightIcon = document.getElementById('theme-toggle-light-icon');

    themeToggleBtn.addEventListener('click', function () {
      darkIcon.classList.toggle('hidden');
      lightIcon.classList.toggle('hidden');

      if (localStorage.getItem('theme')) {
        if (localStorage.getItem('theme') === 'light') {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
        } else {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
        }
      } else {
        if (document.documentElement.classList.contains('dark')) {
          document.documentElement.classList.remove('dark');
          localStorage.setItem('theme', 'light');
        } else {
          document.documentElement.classList.add('dark');
          localStorage.setItem('theme', 'dark');
        }
      }
    });
  </script>
</body>

</html>